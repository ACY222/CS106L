/*  1. Predicate: A predicate is a boolean-valued function, eg:
 *      bool isLessThan(int x, int y) {
 *          return x < y;
 *      }
 *
 *      How can we use isPrime to find a prime number in a vector? We need to
 *      pass a predicate to a function.
 *
 *      Passing functions allows us to generalize an algorithm with user-defined
 *      behaviour
 *
 *  2. Lambda functions: Lambda functions are functions that capture state from
 *  enclosing scope, so that we can add another parameter to pred, eg:
 *      auto lessThanN = [n](int x) { return x < n; }
 *      auto lambda = [capture-values](arguments) {
 *          return expression;
 *      }
 *
 *  3. Functor: A functor is any object that defines an operator (), namely an
 *      object that acts like a function.
 *
 *      When you use a lambda, a functor type is implicitly generated by
 *      compiler
 *  
 *  4. Algorithms: How do we transform and modify containers in a generic way.
 *  
 *      <algorithm> is a collection of template functions
 *
 *  5. Range: Range is a new version of STL. A range is anything with a 
 *      begin and end. std::ranges provides new versions of <algorithm>
 *      for ranges, eg:
 *
 *      std::vector<char> v {'a', 'b', 'c', 'd', 'e'};
 *      auto it = std::ranges::find(v, 'c');
 *
 *      // search from 'b' to 'd'
 *      auto first = v.begin() + 1;
 *      auto last = v.end() + 1;
 *      auto it = std::ranges::find(first, end, 'c');
 *
 *  6. View: A view is a range that lazily adapts another range, which is a way 
 *      to compose algorithms.
 *
 *      View is composable. We can chain view together use operator |
 *      eg:
 *
 *      std::vector<char> v {'a', 'b', 'c', 'd', 'e'};
 *
 *      auto f = std::ranges::views::filter(v, isVowel);
 *      auto t = std::ranges::views::transform(f, toupper);
 *
 *      auto vowelUpper = std::ranges::to<std::vector<char>>(t)
 *
 *      std::vector upperVowel = v
 *          | std::ranges::views::filter(isVowel)
 *          | std::ranges::views::transform(toupper)
 *          | std::ranges::to<std::vector<char>>();
 */
// a normal find
#include <cctype>
#include <functional>
#include <string>
#include <iostream>
#include <vector>

template <typename It, typename T>
It my_find(It first, It last, const T& value) {
    for (auto it = first; it != last; ++it) {
        if (*it == value) return it;
    }
    return last;
}

bool isVowel(char c) {
    c = std::toupper(c);
    return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
}
// a general find
template <typename It, typename Pred>   // Pred is the type of our predicate
It my_find_if(It first, It last, Pred pred) {
    for (auto it = first; it != last; ++it) {
        if (pred(*it)) return it;
    }
    return last;
}

int main() {
    /* std::string corlys = "Lord of the Tides"; */
    /* auto it = my_find_if(corlys.begin(), corlys.end(), isVowel); */
    /* *it = '0'; */
    /* std::cout << corlys << '\n'; */

    /* int n; */
    /* std::cin >> n; */
    /* auto lessThanN = [n](int x) { return x < n; }; */
    /* std::vector<int> v {4, 5, 6, 2, 3, 1}; */
    /* auto it = my_find_if(v.begin(), v.end(), lessThanN); */
    /* std::cout << *it << '\n'; */
    return 0;
}
